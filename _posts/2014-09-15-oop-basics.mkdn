---
layout: post
title:  "Object Oriented Programming"
date:   2014-09-15 03:24:54
categories: update
---

Object Oriented Programming
=================

Javascript - does not have "classes" exactly, but something similar in concept. Instead you can make and modify object templates.

Objects Basics
---------------------

Objects (especially the prototypes we will be usin in JS) are a way of **structuring your code** into smaller chunks.
They typically have two parts to them:

**Methods** - verbs, actions the object can do. These are written as functions inside the object.

**Properties** - nouns, things that define the object. These are the variables inside of an object.

The goal when writing an object is to come up with a set of methods/properties  that adequately defines whatever it is that you are trying to define (or *model*). Here is an example for an Animal:

{% highlight javascript %}


function Animal(animalName) {
    this.name = animalName;   
}

Animal.prototype.move = function(meters) {
    alert(this.name + " moved " + meters + "m.");
}


{% endhighlight %}

Constructor Function, Instances, Using Methods and Properties
----------------------------

**A constructor function is called immediately on object creation.**  In the case of javascript it is simply the function itself that runs and, typically, sets a number of variables inside of the 'this' context. It is used to set up the class and get it read to run. So, when is the constructor called? When you make a *new instance* of the class. Here is how we could make a new instance of our Animal class:

{% highlight javascript %}

var myAnimal:Animal = new Animal("Amorphorous");
myAnimal.move(10);

{% endhighlight %}

The moment that javascript sees `new Animal()` it will create a new *instance* of Animal (essentially creating a new object in javascript memory.) If one writes `new Animal()` again, it will create a **second, distinct object**


Inheritance
---------------------------------------

So we know how to make new objects, how to make new *instances* of those objects, and how to use those objects. Let's move on to **inheritance**. 

One major feature of OOP programming is the ability to make a new object that starts with all of the methods and properties of another object. This is called this **extending** an object. Here's an example with a object, Dog, that extends our animal object:


{% highlight javascript %}

function Dog(animalName) {
    Animal.call(this, name); 
    //this calls the animal 'constructor' on this dog object, running all of the lines of code inside of the animal function as if it were on the dog instead.
}

Dog.prototype = new Animal(); // dog will now have all the methods and properties of of animal

Dog.prototype.bark = function() {
    alert("Woof");
}

{% endhighlight %}

A class that extends another class is typically called a **subclass**, and the class it extends is the **superclass**. In this instance, Animal is the superclass, and Dog is the subclass.

And here is an example of using that class:

{% highlight javascript %}

var myDog:Dog = new Dog("Mr. Woof.");

myDog.bark();

console.log(myDog.name); // "Mr. Woof"

//We can still do everything animal can do
myDog.move(22);


{% endhighlight %}

One way I like to think about inheritance is that it lets you make a class that is *everything and more** than the class it inherits from.

Getters and Setters
--------------------------

Some programming languages have a concept called "getters and setters" which are, essentially, methods that work like properties.

Javascript doesn't have these, but we're going to simulate them with getter and setter functions.

{% highlight javascript %}

function Animal(name) {
    this.name = name;
    this._energy = 10;
}


Animal.prototype.move = function(meters) {
    alert(this.name + " moved " + meters + ".");
    this.energy --;
}

Animal.prototype.digest = function() {
    this.energy ++;
}

Animal.prototype.eat = function() {
    this.digest();
}

Animal.prototype.getEnergy = function() {
    return _energy;
}

Animal.prototype.setEnergy = function(amt) {
    if(amt > 0) {
        this._energy = amt;
    }
}


{% endhighlight %}

This actually introduces three things: private variable naming, the getter function, and the setter function.

Private var naming: notice that the energy variable has been renamed from `energy` to `_energy`. This is a fairly common way to name private variables. If you see an property in a class/object with an underscore, you can be confident it is a private variable. This also helps you distinguish between public and private propertiess. *Note that this is not essential, just good practice*.

Getter: notice that our getter is a function with an extra keyword (**get**). All getter functions *must return a value*. The getter you see above is a very common one. It just has one line of code that returns the private property that the programmer is requesting.

Setter: Our setter function also has a new keywork (**set**). All setter functions must have *one argument* that is the same type of the property you are trying to set. This one above show a good use of a setter function - checking to make sure the data coming into our class is acceptable. (We don't want this particular animal to have *negative* energy. Its not a student who didn't sleep the night before class or anything).

So, how does one use the new functions? Like a property, actually. Lets take a look:

{% highlight javascript %}

var anAnimal:Animal = new Animal('Doofus');


//use our setter function:
myAnimal.energy = 5;

anAnimal.eat();

//uses our getter function:
console.log( anAnimal.getEnergy() ); // 6

{% endhighlight %}

Overriding
----------------------------------

So, speaking of sloths (or very tired students), how might we make a subclass that allows us to set negative energy?


{% highlight javascript %}

function Sloth(name) {
    Animal.call(this, name);
}

Snake.prototype.move = function() {
    alert("Flopping...");
    Animal.move(5);
}

Snake.prototype.setEnergy = function(amt) {
    this._energy = amt;
}

{% endhighlight %}

Overriding a function in a subclass replaces the inherited function with the new one provided. The only caveat is that the argument must take the same arguments, in the same order. THAT'S IT. 

Here, let me prove to you that this sloth can truly have negative energy. (And yes, I understand that I could just write whatever I want and say it works.)

{% highlight javascript %}

var anAmial = new Animal();
anAnimal.energy = -5;
trace(anAnimal.energy); // 0

var aSloth = new Sloth();
sloth.energy = -5;
trace(sloth.energy); //-5

{% endhighlight %}

Including files
------------------------

Larger projects typically will have a **lot** of javascript code. Enough that you will need to break it up into smaller pieces, and include only the parts that you need in certain files as you work. Enter modules and includes.


Different types of modules
--------------------------

Currently there are three module systems one may see referenced in the javasript world:

AMD: Used by require.js, primarily a font-end, asyncronous loading system
commonJS: Used by backend, node developers. Brought to the frontend with the tool **browserify**
ES 6 "Harmony" modules: Soon to be implemented as the base javascript module system.


For this class we'll be using the commonJS approach, with browserify to do some of the heavy lifting.


Modules
--------------------------

At the end of the day it is likely you're going to have a lot of classes and you're going to want to associate them all together in a way that doesn't conflict with other packages of code. Modules are one way of doing this.

Let's build out some classes to go along with this package structure.

**For each of them, note the module.exports at the bottom**

For the subsequent classes, note the require line at the top.

Add these files into 

*Animal.js*

{% highlight javascript %}

function Animal(name) {
    this.name = name;
    this._energy = 10;
}


Animal.prototype.move = function(meters) {
    alert(this.name + " moved " + meters + ".");
    this.energy --;
}

Animal.prototype.digest = function() {
    this.energy ++;
}

Animal.prototype.eat = function() {
    this.digest();
}

Animal.prototype.getEnergy = function() {
    return _energy;
}

Animal.prototype.setEnergy = function(amt) {
    if(amt > 0) {
        this._energy = amt;
    }
}

module.exports = Animal;

{% endhighlight %}

And, we move one through two more classes:

*Mamal.js*

{% highlight javascript %}

var Animal = require("Animal.js")

function Mamal() {
    this.bodyTemp = 10;
    this.hairLength = 2;
}

Mamal.prototype = new Animal();

module.exports = Mamal;

{% endhighlight %}

*Dog.js*

{% highlight javascript %}

var Animal = require("Animal.js");
var Mamal = require("Mamal.js");

function Dog() {
    this.loyalty = 5;
}

Dog.prototype = new Mamal();

Dog.prototype.bark = function() {
    console.log("Woof!");
}

module.exports = Dog;

{% endhighlight %}


Now we've created some files that assume *other files* will be included. 



Importing files (using commonJS, browserify)
---------------------------------------

Before we can move on into the world of breaking our code up, we need to learn how to set up a project to compile our javascript code.

Firstly, one more command line tool, browserify. Install it via the instructions on its site: [http://browserify.org/](http://browserify.org/).

You will need to create one more file, in your root directory (call it app.js). Have it require at least one other file (Dog.js would be a good one).

Navigate to that file, and then run `browserify app.js -o \..\js\app.js`

This will combine all the files that you required ionto one *app.js* file in your js folder.

Setting up grunt to compile automatically
-----------------------------------------

While its cool that we can compile our code via command, its also a bit of a total pain in the butt. It might be useful if we instead got another systehm to do it for us automatically.

This is where grunt - that library you installed way back at the start of class, comes in.

The pieces of grunt
------------------------------

Grunt file - describes what grunt needs to do when it runs it tasks, and what tasks it has available. Some commonly used tasks that grunt can run include starting up small webservers to test your project, turning your Javascript into ugly javascript so that its somewhat harder for people to steal (and a smaller size in general to downloa), and combinining many javascript files into one (via a number of different methods. We'll be using browserify for our needs).

package.json - *technically a node file* this file lists all the external libraries one needs in order for the the project to actually run / compile correctly. 

This, sadly, means that we need to put a few more files into our projects from now on. Here is the templates for each of them

package.json

{% highlight javascript %}
{
  "name": "Project Name",
  "version": "0.0.0",
  "description": "",
  "main": "gruntfile.js",
  "author": "",
  "license": "BSD-2-Clause",
  "dependencies": {},
  "devDependencies": {
    "grunt-browserify": "~3.3.0",
    "grunt": "~0.4.5",
    "grunt-contrib-watch": "~0.6.1"
  }
}

{% endhighlight %}


gruntfile.js

{% highlight javascript %}
module.exports = function(grunt) {

  grunt.initConfig({
    pkg: grunt.file.readJSON('package.json'),    
    browserify: {

        main: {
          options: {
            browserifyOptions: {
              debug: true
            }
          },
          src: 'src/app.js',
          dest: 'scripts/app.js'
        }
    },
    watch: {
      files: [ 'src/**/*.js' ],
      tasks: ['browserify'],
      options: {
          spawn: false,
        },
    }

  });

  grunt.loadNpmTasks('grunt-contrib-watch');
  grunt.loadNpmTasks('grunt-browserify');

  grunt.registerTask('default', [ 'watch']);

};

{% endhighlight %}


In the first file, package.json, we specify the name of the application we are woking on, followed by a series of "dev dependencies", which are things that need to be on the users computer / in the same directory for the development environment to work properly. If they are not on the developer's computer, it can be fixed by navigating to the folder and running `npm install` in the command prompt.

The second file sets up grunt to watch all of the files in the **src** folder, and will automatically compile them into a file in js/app.js *whenever you save any of your .js files*.

Put both of these into your root directory of your project. In PHPSTorm open up the terminal and type `npm install` and wait for everything to install. Then, type 'grunt' to start the task manager to watch for your changes to your files.

**if you want to use browserify, you will need to open the command prompt every time you start working and again run the `grunt` command**


Conclusion
--------------------------------

That's it! Some points:

- OOP aims to recreate objects via methods (functions) and properties (variables)
- OOP classes can *inherit* from other classes, giving them all the methods and properties of the superclass
- Modules are a way to organize your classes.